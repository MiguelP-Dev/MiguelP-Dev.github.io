# GuÃ­a Completa del Paquete `unicode` en Go

El paquete `unicode` en Go proporciona funcionalidades robustas para manejar caracteres Unicode, facilitando operaciones como clasificaciÃ³n, conversiÃ³n y manipulaciÃ³n de texto en diferentes idiomas. Esta guÃ­a explora en profundidad las funciones disponibles con ejemplos prÃ¡cticos.

## ClasificaciÃ³n de Caracteres

### Letras y Caracteres AlfanumÃ©ricos

```go
package main

import (
    "fmt"
    "unicode"
)

func main() {
    // IsLetter - Verifica si un rune es una letra
    fmt.Printf("Â¿Es 'A' una letra? %t\n", unicode.IsLetter('A'))
    fmt.Printf("Â¿Es 'Ã±' una letra? %t\n", unicode.IsLetter('Ã±'))
    fmt.Printf("Â¿Es 'æ¼¢' una letra? %t\n", unicode.IsLetter('æ¼¢'))
    fmt.Printf("Â¿Es '5' una letra? %t\n", unicode.IsLetter('5'))
    
    // IsDigit - Verifica especÃ­ficamente si es un dÃ­gito decimal (0-9)
    fmt.Printf("Â¿Es '7' un dÃ­gito? %t\n", unicode.IsDigit('7'))
    fmt.Printf("Â¿Es 'Ù§' (dÃ­gito Ã¡rabe) un dÃ­gito? %t\n", unicode.IsDigit('Ù§'))
    
    // IsNumber - MÃ¡s amplio que IsDigit, incluye otros tipos de nÃºmeros Unicode
    fmt.Printf("Â¿Es 'Â½' un nÃºmero? %t\n", unicode.IsNumber('Â½'))
    fmt.Printf("Â¿Es 'â…§' (numeral romano) un nÃºmero? %t\n", unicode.IsNumber('â…§'))
    
    // Combinando verificaciones para caracteres alfanumÃ©ricos
    esAlfanumerico := func(r rune) bool {
        return unicode.IsLetter(r) || unicode.IsDigit(r)
    }
    
    fmt.Printf("Â¿Es 'A9' alfanumÃ©rico? %t y %t\n", esAlfanumerico('A'), esAlfanumerico('9'))
}
```

### MayÃºsculas, MinÃºsculas y TÃ­tulo

```go
package main

import (
    "fmt"
    "unicode"
)

func main() {
    // IsUpper - Verifica si es mayÃºscula
    fmt.Printf("Â¿'A' es mayÃºscula? %t\n", unicode.IsUpper('A'))
    fmt.Printf("Â¿'Ã‰' es mayÃºscula? %t\n", unicode.IsUpper('Ã‰'))
    
    // IsLower - Verifica si es minÃºscula
    fmt.Printf("Â¿'a' es minÃºscula? %t\n", unicode.IsLower('a'))
    fmt.Printf("Â¿'Ã±' es minÃºscula? %t\n", unicode.IsLower('Ã±'))
    
    // IsTitle - Detecta caracteres especÃ­ficos que son mayÃºsculas de tÃ­tulo
    // Algunos caracteres especiales tienen forma de tÃ­tulo propia
    fmt.Printf("Â¿'Ç…' (DZ con acento) es un carÃ¡cter de tÃ­tulo? %t\n", unicode.IsTitle('Ç…'))
    
    // Ejemplo prÃ¡ctico: verificar si una palabra comienza con mayÃºscula
    palabra := "EspaÃ±a"
    primerRuna := []rune(palabra)[0]
    fmt.Printf("Â¿'%s' comienza con mayÃºscula? %t\n", palabra, unicode.IsUpper(primerRuna))
}
```

### Espacios y Control

```go
package main

import (
    "fmt"
    "strings"
    "unicode"
)

func main() {
    // IsSpace - Detecta diferentes tipos de espacios en Unicode
    fmt.Printf("Espacio normal: %t\n", unicode.IsSpace(' '))
    fmt.Printf("TabulaciÃ³n: %t\n", unicode.IsSpace('\t'))
    fmt.Printf("Salto de lÃ­nea: %t\n", unicode.IsSpace('\n'))
    fmt.Printf("Espacio no rompible: %t\n", unicode.IsSpace('\u00A0'))
    
    // IsControl - Detecta caracteres de control
    fmt.Printf("Nulo '\\0': %t\n", unicode.IsControl('\u0000'))
    fmt.Printf("Escape '\\e': %t\n", unicode.IsControl('\u001B'))
    fmt.Printf("Delete: %t\n", unicode.IsControl('\u007F'))
    
    // Ejemplo prÃ¡ctico: Eliminar espacios y contar palabras
    texto := "  Hola  mundo!  Â¿CÃ³mo  estÃ¡s?  "
    palabras := strings.FieldsFunc(texto, unicode.IsSpace)
    fmt.Printf("Texto: %q\n", texto)
    fmt.Printf("Palabras: %q\n", palabras)
    fmt.Printf("NÃºmero de palabras: %d\n", len(palabras))
}
```

### SÃ­mbolos y PuntuaciÃ³n

```go
package main

import (
    "fmt"
    "unicode"
)

func main() {
    // IsPunct - Identifica signos de puntuaciÃ³n
    fmt.Printf("Punto '.': %t\n", unicode.IsPunct('.'))
    fmt.Printf("Coma ',': %t\n", unicode.IsPunct(','))
    fmt.Printf("InterrogaciÃ³n '?': %t\n", unicode.IsPunct('?'))
    fmt.Printf("Â¿InterrogaciÃ³n de apertura 'Â¿'? %t\n", unicode.IsPunct('Â¿'))
    
    // IsSymbol - Identifica sÃ­mbolos
    fmt.Printf("DÃ³lar '$': %t\n", unicode.IsSymbol('$'))
    fmt.Printf("Porcentaje '%%': %t\n", unicode.IsSymbol('%'))
    fmt.Printf("Copyright 'Â©': %t\n", unicode.IsSymbol('Â©'))
    fmt.Printf("Emoji 'ðŸ˜Š': %t\n", unicode.IsSymbol('ðŸ˜Š'))
    
    // Diferencia entre sÃ­mbolos y puntuaciÃ³n
    caracteresVarios := []rune{'@', '#', '+', '=', ':', ';', '(', '[', '"'}
    fmt.Println("\nClasificaciÃ³n de caracteres:")
    for _, c := range caracteresVarios {
        fmt.Printf("%q es: PuntuaciÃ³n=%t, SÃ­mbolo=%t\n", 
                  c, unicode.IsPunct(c), unicode.IsSymbol(c))
    }
    
    // IsGraphic y IsPrint - Caracteres con representaciÃ³n visual
    fmt.Printf("\nTabulaciÃ³n '\\t' es: GrÃ¡fico=%t, Imprimible=%t\n", 
               unicode.IsGraphic('\t'), unicode.IsPrint('\t'))
    fmt.Printf("Espacio ' ' es: GrÃ¡fico=%t, Imprimible=%t\n", 
               unicode.IsGraphic(' '), unicode.IsPrint(' '))
    fmt.Printf("Letra 'A' es: GrÃ¡fico=%t, Imprimible=%t\n", 
               unicode.IsGraphic('A'), unicode.IsPrint('A'))
}
```

## TransformaciÃ³n de Caracteres

### ConversiÃ³n de MayÃºsculas/MinÃºsculas

```go
package main

import (
    "fmt"
    "strings"
    "unicode"
)

func main() {
    // ToUpper - Convertir a mayÃºsculas
    fmt.Printf("'a' â†’ %q\n", unicode.ToUpper('a'))
    fmt.Printf("'Ã±' â†’ %q\n", unicode.ToUpper('Ã±'))
    fmt.Printf("'Ã©' â†’ %q\n", unicode.ToUpper('Ã©'))
    
    // ToLower - Convertir a minÃºsculas
    fmt.Printf("'A' â†’ %q\n", unicode.ToLower('A'))
    fmt.Printf("'Ã‘' â†’ %q\n", unicode.ToLower('Ã‘'))
    fmt.Printf("'Ã‰' â†’ %q\n", unicode.ToLower('Ã‰'))
    
    // ToTitle - Convertir a tÃ­tulo (similar a mayÃºscula pero especÃ­fico para tÃ­tulo)
    fmt.Printf("'a' a tÃ­tulo â†’ %q\n", unicode.ToTitle('a'))
    fmt.Printf("'Ã±' a tÃ­tulo â†’ %q\n", unicode.ToTitle('Ã±'))
    
    // SimpleFold - Iterar por el conjunto de equivalencias de plegado
    c := 'A'
    fmt.Printf("Iterando por plegado de %q: ", c)
    for i := 0; i < 3; i++ {
        c = unicode.SimpleFold(c)
        fmt.Printf("%q ", c)
    }
    fmt.Println()
    
    // Ejemplo prÃ¡ctico: Convertir strings completos
    frase := "Â¡Hola Mundo!"
    mayusculas := strings.Map(unicode.ToUpper, frase)
    minusculas := strings.Map(unicode.ToLower, frase)
    fmt.Printf("Original: %s\n", frase)
    fmt.Printf("MayÃºsculas: %s\n", mayusculas)
    fmt.Printf("MinÃºsculas: %s\n", minusculas)
}
```

## Tablas Unicode y Rangos

El paquete `unicode` define mÃºltiples rangos y tablas que agrupan caracteres por categorÃ­as o propiedades.

```go
package main

import (
    "fmt"
    "unicode"
)

func main() {
    // Rangos predefinidos en el paquete unicode
    fmt.Println("Rangos Unicode:")
    
    // Letras latinas
    fmt.Printf("'A' es letra latina: %t\n", unicode.In('A', unicode.Latin))
    fmt.Printf("'Î±' (alfa griego) es letra latina: %t\n", unicode.In('Î±', unicode.Latin))
    
    // Letras griegas
    fmt.Printf("'Î±' es letra griega: %t\n", unicode.In('Î±', unicode.Greek))
    fmt.Printf("'Î©' es letra griega: %t\n", unicode.In('Î©', unicode.Greek))
    
    // Caracteres cirÃ­licos
    fmt.Printf("'Ð¯' es letra cirÃ­lica: %t\n", unicode.In('Ð¯', unicode.Cyrillic))
    
    // Caracteres asiÃ¡ticos
    fmt.Printf("'æ¼¢' es un carÃ¡cter Han: %t\n", unicode.In('æ¼¢', unicode.Han))
    
    // Combinar rangos con funciones de clasificaciÃ³n
    esLetraLatina := func(r rune) bool {
        return unicode.IsLetter(r) && unicode.In(r, unicode.Latin)
    }
    
    fmt.Printf("'A' es letra latina: %t\n", esLetraLatina('A'))
    fmt.Printf("'Î±' es letra latina: %t\n", esLetraLatina('Î±'))
}
```

## Scripts y Propiedades Unicode

```go
package main

import (
    "fmt"
    "unicode"
)

func main() {
    // Usando tablas de propiedades
    fmt.Printf("'A' es parte del script latino: %t\n", 
               unicode.Is(unicode.Latin, 'A'))
    fmt.Printf("'æ¼¢' es parte del script Han: %t\n", 
               unicode.Is(unicode.Han, 'æ¼¢'))
    fmt.Printf("'Î±' es parte del script griego: %t\n", 
               unicode.Is(unicode.Greek, 'Î±'))
    
    // Combinando mÃºltiples scripts
    caracteresVarios := []rune{'A', 'Î±', 'æ¼¢', 'Ð¯', '9', 'Â©'}
    for _, c := range caracteresVarios {
        fmt.Printf("%q pertenece a: ", c)
        
        if unicode.Is(unicode.Latin, c) {
            fmt.Printf("Latino ")
        }
        if unicode.Is(unicode.Greek, c) {
            fmt.Printf("Griego ")
        }
        if unicode.Is(unicode.Han, c) {
            fmt.Printf("Han ")
        }
        if unicode.Is(unicode.Cyrillic, c) {
            fmt.Printf("CirÃ­lico ")
        }
        
        fmt.Println()
    }
}
```

## Casos PrÃ¡cticos

### ValidaciÃ³n de Entrada

```go
package main

import (
    "fmt"
    "strings"
    "unicode"
)

// Validar un nombre de usuario que solo permite letras, nÃºmeros y guiones bajos
func esNombreUsuarioValido(nombre string) bool {
    if len(nombre) < 3 || len(nombre) > 20 {
        return false
    }
    
    for _, r := range nombre {
        if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' {
            return false
        }
    }
    
    // El nombre debe comenzar con una letra
    return unicode.IsLetter([]rune(nombre)[0])
}

// Validar una contraseÃ±a con requisitos de seguridad
func esContraseÃ±aSegura(pass string) (bool, string) {
    if len(pass) < 8 {
        return false, "La contraseÃ±a debe tener al menos 8 caracteres"
    }
    
    var tieneMayuscula, tieneMinuscula, tieneDigito, tieneSimbolo bool
    
    for _, r := range pass {
        if unicode.IsUpper(r) {
            tieneMayuscula = true
        } else if unicode.IsLower(r) {
            tieneMinuscula = true
        } else if unicode.IsDigit(r) {
            tieneDigito = true
        } else if unicode.IsPunct(r) || unicode.IsSymbol(r) {
            tieneSimbolo = true
        }
    }
    
    if !tieneMayuscula {
        return false, "Debe incluir al menos una letra mayÃºscula"
    }
    if !tieneMinuscula {
        return false, "Debe incluir al menos una letra minÃºscula"
    }
    if !tieneDigito {
        return false, "Debe incluir al menos un dÃ­gito"
    }
    if !tieneSimbolo {
        return false, "Debe incluir al menos un sÃ­mbolo"
    }
    
    return true, "ContraseÃ±a vÃ¡lida"
}

func main() {
    // Probar validaciÃ³n de nombre de usuario
    nombresUsuario := []string{"usuario123", "Usuario_1", "123user", "us@er", "a"}
    fmt.Println("ValidaciÃ³n de nombres de usuario:")
    for _, nombre := range nombresUsuario {
        fmt.Printf("%q es vÃ¡lido: %t\n", nombre, esNombreUsuarioValido(nombre))
    }
    
    // Probar validaciÃ³n de contraseÃ±a
    contraseÃ±as := []string{"abc123", "Password1", "Passw0rd!", "CONTRASEÃ‘A123", "contraseÃ±a!"}
    fmt.Println("\nValidaciÃ³n de contraseÃ±as:")
    for _, pass := range contraseÃ±as {
        valida, mensaje := esContraseÃ±aSegura(pass)
        fmt.Printf("%q: %s\n", pass, mensaje)
    }
}
```

### Procesamiento de Texto

```go
package main

import (
    "fmt"
    "strings"
    "unicode"
)

// Normalizar texto eliminando espacios extras y convirtiendo a minÃºsculas
func normalizarTexto(texto string) string {
    // Convertir a minÃºsculas
    texto = strings.Map(unicode.ToLower, texto)
    
    // Eliminar espacios duplicados
    var resultado strings.Builder
    espacioAnterior := true // Para manejar espacios al inicio
    
    for _, r := range texto {
        if unicode.IsSpace(r) {
            if !espacioAnterior {
                resultado.WriteRune(' ')
                espacioAnterior = true
            }
        } else {
            resultado.WriteRune(r)
            espacioAnterior = false
        }
    }
    
    return strings.TrimSpace(resultado.String())
}

// Contar palabras, separando correctamente por Unicode
func contarPalabras(texto string) int {
    palabras := strings.FieldsFunc(texto, unicode.IsSpace)
    return len(palabras)
}

// Convertir a formato tÃ­tulo (primera letra de cada palabra en mayÃºscula)
func formatoTitulo(texto string) string {
    palabras := strings.FieldsFunc(texto, unicode.IsSpace)
    for i, palabra := range palabras {
        if len(palabra) > 0 {
            runas := []rune(palabra)
            runas[0] = unicode.ToTitle(runas[0])
            palabras[i] = string(runas)
        }
    }
    return strings.Join(palabras, " ")
}

// Sanitizar texto para URLs (eliminar acentos, espacios, etc.)
func sanitizarParaURL(texto string) string {
    texto = strings.Map(func(r rune) rune {
        if unicode.IsLetter(r) || unicode.IsDigit(r) {
            // Convertir letras a minÃºsculas
            return unicode.ToLower(r)
        } else if unicode.IsSpace(r) {
            return '-'
        }
        // Eliminar cualquier otro carÃ¡cter
        return -1
    }, texto)
    
    // Eliminar guiones duplicados
    for strings.Contains(texto, "--") {
        texto = strings.ReplaceAll(texto, "--", "-")
    }
    
    return strings.Trim(texto, "-")
}

func main() {
    texto := "  Â¡Hola   MUNDO!  Â¿CÃ³mo    estÃ¡s? ðŸ˜Š  "
    
    fmt.Printf("Original: %q\n", texto)
    fmt.Printf("Normalizado: %q\n", normalizarTexto(texto))
    fmt.Printf("Palabras: %d\n", contarPalabras(texto))
    fmt.Printf("Formato tÃ­tulo: %q\n", formatoTitulo(normalizarTexto(texto)))
    
    tituloArticulo := "CÃ³mo Aprender Go: Una GuÃ­a PrÃ¡ctica (2023)"
    fmt.Printf("\nTÃ­tulo original: %q\n", tituloArticulo)
    fmt.Printf("URL amigable: %q\n", sanitizarParaURL(tituloArticulo))
}
```

## Rendimiento y Optimizaciones

```go
package main

import (
    "fmt"
    "strings"
    "time"
    "unicode"
)

func main() {
    // Texto de prueba grande
    textoGrande := strings.Repeat("Â¡Hola Mundo! Â¿CÃ³mo estÃ¡s? 123 Î±Î²Î³ æ¼¢å­— ", 10000)
    
    // MÃ©todo 1: Usar unicode.Is* en cada carÃ¡cter
    inicio := time.Now()
    contarCaracteresPorTipo1 := func(texto string) (letras, digitos, espacios, otros int) {
        for _, r := range texto {
            if unicode.IsLetter(r) {
                letras++
            } else if unicode.IsDigit(r) {
                digitos++
            } else if unicode.IsSpace(r) {
                espacios++
            } else {
                otros++
            }
        }
        return
    }
    l1, d1, e1, o1 := contarCaracteresPorTipo1(textoGrande)
    duracion1 := time.Since(inicio)
    
    // MÃ©todo 2: Combinar bÃºsquedas usando tablas
    inicio = time.Now()
    contarCaracteresPorTipo2 := func(texto string) (letras, digitos, espacios, otros int) {
        for _, r := range texto {
            switch {
            case unicode.IsLetter(r):
                letras++
            case unicode.IsDigit(r):
                digitos++
            case unicode.IsSpace(r):
                espacios++
            default:
                otros++
            }
        }
        return
    }
    l2, d2, e2, o2 := contarCaracteresPorTipo2(textoGrande)
    duracion2 := time.Since(inicio)
    
    fmt.Println("ComparaciÃ³n de rendimiento:")
    fmt.Printf("MÃ©todo 1: %v (Letras: %d, DÃ­gitos: %d, Espacios: %d, Otros: %d)\n", 
               duracion1, l1, d1, e1, o1)
    fmt.Printf("MÃ©todo 2: %v (Letras: %d, DÃ­gitos: %d, Espacios: %d, Otros: %d)\n", 
               duracion2, l2, d2, e2, o2)
    
    fmt.Printf("Rendimiento relativo: %.2f%%\n", 
               float64(duracion1.Nanoseconds())/float64(duracion2.Nanoseconds())*100)
}
```

## ConclusiÃ³n

El paquete `unicode` de Go proporciona herramientas robustas para manejar texto internacional y caracteres Unicode de forma eficiente. Es especialmente Ãºtil para:

1. ValidaciÃ³n de entrada de usuario
2. Procesamiento y normalizaciÃ³n de texto
3. ManipulaciÃ³n de cadenas multilingÃ¼es
4. IdentificaciÃ³n y clasificaciÃ³n de caracteres
5. Operaciones de conversiÃ³n entre mayÃºsculas y minÃºsculas

Al explotar el poder de este paquete, puedes crear aplicaciones Go que manejen texto de manera precisa y eficiente, independientemente del idioma o script utilizado.
